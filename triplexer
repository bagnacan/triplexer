#!/usr/bin/env python3

#
# module for launching triplexer pipeline operations
#

import argparse
import logging
import microrna_org
import os
import redis
import sys
from common import *
from pathlib import Path


MODULE = os.path.basename(sys.argv[0])


# parser
#
parser = argparse.ArgumentParser(
    prog=MODULE,
    description="Predict and simulate putative RNA triplexes.",
    formatter_class=argparse.RawTextHelpFormatter)

parser.add_argument(
    "-v",
    "--version",
    action="version",
    version=str("%(prog)s " + VERSION),
    help="print the version and exit"
)
parser.add_argument(
    "-c",
    "--conf",
    metavar="CONF",
    default="conf.yaml",
    type=argparse.FileType("r"),
    help="set %(metavar)s as configuration file"
)
parser.add_argument(
    OPT_CORES_SHORT,
    OPT_CORES_EXT,
    metavar="CORES",
    default="2",
    help="set %(metavar)s as number of parallel processes"
)
parser.add_argument(
    OPT_DB_SHORT,
    OPT_DB_EXT,
    metavar="DB",
    default="redis:6379",
    help="set %(metavar)s as intermediate results database"
)


# operation parser
#
parser_op = parser.add_argument_group("operations (require "
    + OPT_NAMESPACE_SHORT + ")")
parser_op.add_argument(
    OPT_INIT_NS_SHORT,
    OPT_INIT_NS_EXT,
    action="store_true",
    default=argparse.SUPPRESS,
    help=str("initialize the cache with putative RNA triplexes\n"
        + "(same as " + " ".join( str(x) for x in OPT_INIT_NS_SAME_AS_CLI)
        + ")")
)
parser_op.add_argument(
    OPT_READ_SHORT,
    OPT_READ_EXT,
    action="store_true",
    default=argparse.SUPPRESS,
    help=str("read the provided dataset in memory")
)
parser_op.add_argument(
    OPT_FILTRATE_SHORT,
    OPT_FILTRATE_EXT,
    action="store_true",
    default=argparse.SUPPRESS,
    help=str("filter entries not forming putative triplexes")
)
parser_op.add_argument(
    OPT_PREDICT_SHORT,
    OPT_PREDICT_EXT,
    action="store_true",
    default=argparse.SUPPRESS,
    help="predict putative triplexes"
)
parser_op.add_argument(
    OPT_TEST_SHORT,
    OPT_TEST_EXT,
    action="store_true",
    default=argparse.SUPPRESS,
    help="test stability of predicted triplexes"
)


# namespace parser
#
supported_namespaces = get_supported_namespaces() # supported namespaces
parser_ns = parser.add_argument_group("namespace")
parser_ns.add_argument(
    OPT_NAMESPACE_SHORT,
    OPT_NAMESPACE_EXT,
    metavar="NS",
    default="test",
    help=str("set %(metavar)s as model organism namespace\n"
        + "supported %(metavar)s (default \"%(default)s\"):\n"
        + supported_namespaces))



# logger
logger = logging.getLogger(MODULE)


# file logger
LOGFILE = FILE_PATH.joinpath(str(TRIPLEXER + FILE_EXT_LOG))
logging.basicConfig(
    level = logging.DEBUG,
    format = "%(asctime)s %(name)-12s %(levelname)-8s %(message)s",
    datefmt = "%Y-%m-%d %H:%M",
    filename = LOGFILE,
    filemode = "w")


# console logger
console = logging.StreamHandler()
console.setLevel(logging.INFO)
formatter = logging.Formatter("%(message)s")
console.setFormatter(formatter)
logging.getLogger("").addHandler(console)


# operation launcher
launch = {
    MICRORNA_ORG : {
        OPT_INIT_NS: microrna_org.init_ns,
        OPT_READ: microrna_org.read,
        OPT_FILTRATE: microrna_org.filtrate
    }
}



#
# check provided file is a file, and return its path
#
def is_file(parser, f):
    """
    Checks whether the provided file is a file and return its path.
    """
    if not os.path.isfile(f):
        logger.error("Provided file %s is not a file", f)
        parser.print_help(file=sys.stderr)
        sys.exit(2)

    else:
        return os.path.realpath(f)



#
# run the operation
#
def run(operation, cli_args):
    """
    Runs an operation.
    """

    ns_code = cli_args[OPT_NAMESPACE]
    ns = NAMESPACES[ns_code][STRING].split(SEPARATOR)[0]

    logger.info("Operation \"%s\" started", operation)
    launch[ns][operation](cache, cli_args)
    logger.info("Operation \"%s\" completed", operation)



#
# main
#
if __name__ == "__main__":

    # parse the command line invocation:
    args, non_args = parser.parse_known_args()

    # no CLI arguments
    # ==> print the help and exit
    if len(sys.argv) == 1:
        parser.print_help(file=sys.stderr)
        sys.exit(0)

    # unrecognised CLI arguments
    # ==> print the help and exit
    if non_args:
        logger.error("Wrong command line invocation. Exiting")
        parser.print_help(file=sys.stderr)
        sys.exit(2)


    # collect CLI arguments
    cli_args = dict(vars(args))


    # underlying redis cache not reachable
    # ==> exit
    logger.info("Checking redis cache at %s", cli_args[OPT_DB])
    cache = redis.Redis(
        charset="utf-8", decode_responses=True,
        host=cli_args[OPT_DB].split(SEPARATOR)[0],
        port=cli_args[OPT_DB].split(SEPARATOR)[1],
        db=0)
    try:
        cache.ping()
    except redis.RedisError:
        logger.error("Redis instance not running. Exiting")
        sys.exit(2)


    # launch all operations given on the CLI
    for op in OPS:
        if op in cli_args.keys():
            run(op, cli_args)

