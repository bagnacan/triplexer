#!/usr/bin/env python3

#
# module for launching triplexer pipeline operations
#

import argparse
import logging
import microrna_org
import os
import redis
import sys
from common import *


MODULE = os.path.basename(sys.argv[0])


# parser
parser = argparse.ArgumentParser(
    prog=MODULE,
    description="Predict and simulate putative RNA triplexes.",
    formatter_class=argparse.ArgumentDefaultsHelpFormatter
)
parser.add_argument(
    "-v",
    "--version",
    action="version",
    version=str("%(prog)s " + VERSION),
    help="print the version and exit"
)
parser.add_argument(
    "-c",
    "--conf",
    metavar="CONF",
    default="conf.yaml",
    type=argparse.FileType("r"),
    help="set %(metavar)s as configuration file"
)
parser.add_argument(
    OPT_CORES_SHORT,
    OPT_CORES_EXT,
    metavar="CORES",
    default="2",
    help="set %(metavar)s as number of parallel processes"
)
parser.add_argument(
    OPT_DB_SHORT,
    OPT_DB_EXT,
    metavar="DB",
    default="127.0.0.1:6379",
    help="set %(metavar)s as intermediate results database"
)


# organism data parser
parser_to = parser.add_argument_group("target organism data")
parser_to.add_argument(
    OPT_ORGANISM_SHORT,
    OPT_ORGANISM_EXT,
    metavar="ORG",
    default=argparse.SUPPRESS,
    help="set %(metavar)s as model organism"
)
parser_to.add_argument(
    OPT_NAMESPACE_SHORT,
    OPT_NAMESPACE_EXT,
    metavar="NS",
    default=argparse.SUPPRESS,
    help="set %(metavar)s as model organism namespace"
)
parser_to.add_argument(
    OPT_GENOME_SHORT,
    OPT_GENOME_EXT,
    metavar="GEN",
    default=argparse.SUPPRESS,
    help="set %(metavar)s as model organism genome release"
)
parser_to.add_argument(
    OPT_INPUT_SHORT,
    OPT_INPUT_EXT,
    metavar="INPUT",
    type=(lambda x: is_file(parser, x)),
    default=argparse.SUPPRESS,
    help="set %(metavar)s as model organism input dataset"
)


# operation parser
parser_op = parser.add_argument_group("operations")
parser_op.add_argument(
    OPT_STORE_SHORT,
    OPT_STORE_EXT,
    action="store_true",
    default=argparse.SUPPRESS,
    help=str(
        "store the provided dataset (requires: " +
        ", ".join( str(x) for x in OPT_STORE_REQUIRE_CLI) + ")"
    )
)
parser_op.add_argument(
    OPT_FILTER_SHORT,
    OPT_FILTER_EXT,
    action="store_true",
    default=argparse.SUPPRESS,
    help=str(
        "filter entries not forming putative triplexes (requires: " +
        ", ".join( str(x) for x in OPT_FILTER_REQUIRE_CLI) + ")"
    )
)
parser_op.add_argument(
    OPT_PREDICT_SHORT,
    OPT_PREDICT_EXT,
    action="store_true",
    default=argparse.SUPPRESS,
    help="predict putative triplexes"
)
parser_op.add_argument(
    OPT_TEST_SHORT,
    OPT_TEST_EXT,
    action="store_true",
    default=argparse.SUPPRESS,
    help="test stability of predicted triplexes"
)


# logger
logger = logging.getLogger(MODULE)


# file logger
LOGFILE = str("/tmp/" + MODULE + ".log")
logging.basicConfig(
    level = logging.DEBUG,
    format = "%(asctime)s %(name)-12s %(levelname)-8s %(message)s",
    datefmt = "%Y-%m-%d %H:%M",
    filename = LOGFILE,
    filemode = "w")


# console logger
console = logging.StreamHandler()
console.setLevel(logging.INFO)
formatter = logging.Formatter("%(message)s")
console.setFormatter(formatter)
logging.getLogger("").addHandler(console)


# operation launcher
launch = {
    OPT_STORE: microrna_org.store,
    OPT_FILTER: microrna_org.filter
}



#
# check provided file is a file, and return its path
#
def is_file(parser, f):
    """
    Checks whether the provided file is a file and return its path.
    """
    if not os.path.isfile(f):
        logger.error("Provided file %s is not a file", f)
        parser.print_help(file=sys.stderr)
        sys.exit(2)

    else:
        return os.path.realpath(f)



#
# check provided option satisfy dependencies
#
def operation_provides_required_options(operation, options):
    """
    Checks whether the provided set of operation's options complies with the
    operation's set of required options.
    """
    required_options = OPTS_DEPENDENCIES[operation]

    provided_options = [
        x for x in required_options if options[x] is not None
    ]

    # ceck whether the mandatory options are provided
    if set(provided_options) != set(required_options):
        logger.error("Missing required options for operation \"%s\".",
            operation)
        return False

    else:
        return True



#
# run the operation
#
def run(operation, options):
    """
    Runs an operation.
    """

    logger.info("Operation \"%s\" started", operation)
    launch[operation](cache, options)
    logger.info("Operation \"%s\" completed", operation)



#
# check if an operation is followed by its required options
#
def check_operation_options(operation, options):
    """
    Checks if an operation's mandatory options are provided.
    """



#
# main
#
if __name__ == "__main__":

    # parse the command line invocation:
    args, non_args = parser.parse_known_args()

    # no options arguments provided
    # ==> print the help and exit
    if len(sys.argv) == 1:
        parser.print_help(file=sys.stderr)
        sys.exit(0)

    # unrecognised arguments
    # ==> print the help and exit
    if non_args:
        logger.error("Wrong command line invocation. Exiting")
        parser.print_help(file=sys.stderr)
        sys.exit(2)


    options = dict(vars(args))


    # operation precedence:
    operations = [
        OPT_STORE,
        OPT_FILTER,
        OPT_PREDICT,
        OPT_TEST
    ]


    # provided operation does not indicate mandatory options
    # ==> print help and exit
    for operation in operations:

        if (operation in options.keys()) and (not operation_provides_required_options(operation, options)):
            logger.error("Operation \"%s\" is missing mandatory options. Exiting", operation)
            parser.print_help(file=sys.stderr)
            sys.exit(2)

    # underlying redis cache not reachable
    # ==> exit
    logger.info("Checking redis cache at %s", options[OPT_DB])
    cache = redis.Redis(
        host=options[OPT_DB].split(SEPARATOR)[0],
        port=options[OPT_DB].split(SEPARATOR)[1],
        db=0)
    try:
        cache.ping()
    except redis.RedisError:
        logger.error("Redis instance not running. Exiting")
        sys.exit(2)


    # launch all the provided operations
    for operation in operations:
        if operation in options.keys():
            run(operation, options)

