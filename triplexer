#!/usr/bin/env python3

#
# module for launching triplexer pipeline operations
#

import argparse
import logging
import microrna_org
import os
import redis
import sys
from common import *


MODULE = os.path.basename(sys.argv[0])


# parser
parser = argparse.ArgumentParser(
    prog=MODULE,
    description="Predict and simulate putative RNA triplexes."
)
parser.add_argument(
    "-v",
    "--version",
    action="version",
    version=str("%(prog)s " + VERSION),
    help="print the version and exit"
)
parser.add_argument(
    "-i",
    "--init",
    metavar="CONF",
    default="conf.yaml",
    type=argparse.FileType("r"),
    help="set %(metavar)s as the init configuration file (default: %(default)s)"
)
parser.add_argument(
    OPT_CORES_SHORT,
    OPT_CORES_EXT,
    metavar="CORES",
    default="2",
    help="set %(metavar)s as the number of parallel execution cores (default: %(default)s)"
)
parser.add_argument(
    OPT_LOCATION_SHORT,
    OPT_LOCATION_EXT,
    metavar="STORE",
    default="127.0.0.1:6379",
    help="set %(metavar)s as the location for all intermediate results (default: %(default)s)"
)
parser.add_argument(
    OPT_LOCATION_DB_SHORT,
    OPT_LOCATION_DB_EXT,
    metavar="DB",
    default="0",
    help="set %(metavar)s as the location database for all intermediate results (default: %(default)s)"
)


# organism data parser
parser_to = parser.add_argument_group("target organism data")
parser_to.add_argument(
    OPT_ORGANISM_SHORT,
    OPT_ORGANISM_EXT,
    metavar="ORG",
    help="set %(metavar)s as the target organism"
)
parser_to.add_argument(
    OPT_NAMESPACE_SHORT,
    OPT_NAMESPACE_EXT,
    metavar="NS",
    help="set %(metavar)s as the target organism's namespace"
)
parser_to.add_argument(
    OPT_GENOME_SHORT,
    OPT_GENOME_EXT,
    metavar="GEN",
    help="set %(metavar)s as the target organism's genome release"
)
parser_to.add_argument(
    OPT_FILE_SHORT,
    OPT_FILE_EXT,
    metavar="FILE",
    type=(lambda x: is_file(parser, x)),
    help="set %(metavar)s as the target organism's source dataset file"
)


# operation parser
parser_op = parser.add_argument_group("operations")
parser_op.add_argument(
    OPT_CACHE_SHORT,
    OPT_CACHE_EXT,
    action="store_true",
    help=str(
        "cache the provided source dataset (requires options " +
        ", ".join( str(x) for x in OPT_CACHE_REQUIRE_CLI) + ")"
    )
)
parser_op.add_argument(
    OPT_ALLOWED_SHORT,
    OPT_ALLOWED_EXT,
    action="store_true",
    help=str(
        "discard all cached entries that do not form any putative triplex (requires options " +
        ", ".join( str(x) for x in OPT_ALLOWED_REQUIRE_CLI) + ")"
    )
)
parser_op.add_argument(
    OPT_PREDICT_SHORT,
    OPT_PREDICT_EXT,
    action="store_true",
    help="predict putative triplexes"
)
parser_op.add_argument(
    OPT_SIMULATE_SHORT,
    OPT_SIMULATE_EXT,
    action="store_true",
    help="simulate the stability of predicted putative triplexes"
)


# logger
logger = logging.getLogger(MODULE)


# file logger
LOGFILE = str("/tmp/" + MODULE + ".log")
logging.basicConfig(
    level = logging.DEBUG,
    format = "%(asctime)s %(name)-12s %(levelname)-8s %(message)s",
    datefmt = "%Y-%m-%d %H:%M",
    filename = LOGFILE,
    filemode = "w")


# console logger
console = logging.StreamHandler()
console.setLevel(logging.INFO)
formatter = logging.Formatter("%(message)s")
console.setFormatter(formatter)
logging.getLogger("").addHandler(console)


# operation launcher
launch = {
    OPT_CACHE: microrna_org.cache,
    OPT_ALLOWED: microrna_org.allowed
}



#
# check provided file is a file, and return its path
#
def is_file(parser, f):
    """
    Checks whether the provided file is a file and return its path.
    """
    if not os.path.isfile(f):
        logger.error("Provided file %s is not a file", f)
        parser.print_help(file=sys.stderr)
        sys.exit(2)

    else:
        return os.path.realpath(f)



#
# check provided option satisfy dependencies
#
def provides_required_options(operation, options):
    """
    Checks whether the provided set of operation's options complies with the
    operation's set of required options.
    """
    required_options = OPTS_DEPENDENCIES[operation]

    provided_options = [
        x for x in required_options if options[x] is not None
    ]

    # ceck whether the mandatory options are provided
    if set(provided_options) != set(required_options):
        logger.error("Missing required options for operation \"%s\".",
            operation)
        return False

    else:
        return True



#
# run the operation
#
def run(operation, options):
    """
    Checks if an operation's mandatory options are provided, and runs it.
    """

    # check whether the options contain the desired operation
    if options[operation]:

        # check the operation's required options, and launch it
        if provides_required_options(operation, options):
            logger.info("Operation \"%s\" started", operation)
            launch[operation](store, options)
            logger.info("Operation \"%s\" completed", operation)
        else:
            parser.print_help(file=sys.stderr)
            sys.exit(2)


#
# main
#
if __name__ == "__main__":

    # parse the command line invocation:
    args, non_args = parser.parse_known_args()

    # unrecognised arguments
    # ==> print the help and exit
    if non_args:
        logger.error("Wrong command line invocation. Exiting")
        parser.print_help(file=sys.stderr)
        sys.exit(2)

    # no options arguments provided
    # ==> print the help and exit
    if len(sys.argv) == 1:
        parser.print_help(file=sys.stderr)
        sys.exit(0)


    options = dict(vars(args))


    # check whether the underlying redis cache is reachable
    logger.info("Checking redis cache at %s", options[OPT_LOCATION])
    store = redis.StrictRedis(
        host=options[OPT_LOCATION].split(SEPARATOR)[0],
        port=options[OPT_LOCATION].split(SEPARATOR)[1],
        db=options[OPT_LOCATION_DB])
    try:
        store.ping()
    except redis.RedisError:
        logger.error("Redis instance not running. Exiting")
        sys.exit(2)


    # operation precedence:
    operations = [
        OPT_CACHE,
        OPT_ALLOWED,
        OPT_PREDICT,
        OPT_SIMULATE
    ]


    # check each operation's required parameters, and launch it
    for operation in operations:
        run(operation, options)

