#!/usr/bin/env python3

#
# module for launching triplexer pipeline operations
#

import argparse
import logging
import microrna_org
import os
import redis
import sys
from common import *


MODULE = os.path.basename(sys.argv[0])


# parser
parser = argparse.ArgumentParser(
    prog=MODULE,
    description="Predict and simulate putative RNA triplexes.",
    formatter_class=argparse.RawTextHelpFormatter)

parser.add_argument(
    "-v",
    "--version",
    action="version",
    version=str("%(prog)s " + VERSION),
    help="print the version and exit"
)
parser.add_argument(
    "-c",
    "--conf",
    metavar="CONF",
    default="conf.yaml",
    type=argparse.FileType("r"),
    help="set %(metavar)s as configuration file"
)
parser.add_argument(
    OPT_CORES_SHORT,
    OPT_CORES_EXT,
    metavar="CORES",
    default="2",
    help="set %(metavar)s as number of parallel processes"
)
parser.add_argument(
    OPT_DB_SHORT,
    OPT_DB_EXT,
    metavar="DB",
    default="redis:6379",
    help="set %(metavar)s as intermediate results database"
)


# operation parser
parser_op = parser.add_argument_group("operations")

parser_op.add_argument(
    OPT_INIT_NS_SHORT,
    OPT_INIT_NS_EXT,
    metavar="NS",
    default="1",
    help=str("initialize the cache by storing the putative\n"
        + "triplexes of namespace %(metavar)s. Supported %(metavar)s are:\n"
        + "+----+----------------------------------+\n"
        + "| NS | database:version:organism:genome |\n"
        + "+----+----------------------------------+\n"
        + "|  1 | microrna.org:Aug.2010:hsa:hg19   |\n"
        + "+----+----------------------------------+\n"
        + "|  2 | microrna.org:Aug.2010:mmu:mm10   |\n"
        + "+----+----------------------------------+"))

parser_op.add_argument(
    OPT_READ_SHORT,
    OPT_READ_EXT,
    action="store_true",
    default=argparse.SUPPRESS,
    help=str(
        "read the provided dataset in memory (requires: " +
        ", ".join( str(x) for x in OPT_READ_REQUIRE_CLI) + ")"
    )
)
parser_op.add_argument(
    OPT_FILTER_SHORT,
    OPT_FILTER_EXT,
    action="store_true",
    default=argparse.SUPPRESS,
    help=str(
        "filter entries not forming putative triplexes (requires: " +
        ", ".join( str(x) for x in OPT_FILTER_REQUIRE_CLI) + ")"
    )
)
parser_op.add_argument(
    OPT_PREDICT_SHORT,
    OPT_PREDICT_EXT,
    action="store_true",
    default=argparse.SUPPRESS,
    help="predict putative triplexes"
)
parser_op.add_argument(
    OPT_TEST_SHORT,
    OPT_TEST_EXT,
    action="store_true",
    default=argparse.SUPPRESS,
    help="test stability of predicted triplexes"
)


# organism data parser
parser_to = parser.add_argument_group("target organism")
parser_to.add_argument(
    OPT_ORGANISM_SHORT,
    OPT_ORGANISM_EXT,
    metavar="ORG",
    default=argparse.SUPPRESS,
    help="set %(metavar)s as model organism"
)
parser_to.add_argument(
    OPT_NAMESPACE_SHORT,
    OPT_NAMESPACE_EXT,
    metavar="NS",
    default=argparse.SUPPRESS,
    help="set %(metavar)s as model organism namespace"
)
parser_to.add_argument(
    OPT_GENOME_SHORT,
    OPT_GENOME_EXT,
    metavar="GEN",
    default=argparse.SUPPRESS,
    help="set %(metavar)s as model organism genome release"
)
parser_to.add_argument(
    OPT_INPUT_SHORT,
    OPT_INPUT_EXT,
    metavar="INPUT",
    type=(lambda x: is_file(parser, x)),
    default=argparse.SUPPRESS,
    help="set %(metavar)s as model organism input dataset"
)


# logger
logger = logging.getLogger(MODULE)


# file logger
LOGFILE = str("/tmp/" + MODULE + ".log")
logging.basicConfig(
    level = logging.DEBUG,
    format = "%(asctime)s %(name)-12s %(levelname)-8s %(message)s",
    datefmt = "%Y-%m-%d %H:%M",
    filename = LOGFILE,
    filemode = "w")


# console logger
console = logging.StreamHandler()
console.setLevel(logging.INFO)
formatter = logging.Formatter("%(message)s")
console.setFormatter(formatter)
logging.getLogger("").addHandler(console)


# operation launcher
launch = {
    OPT_READ: microrna_org.read,
    OPT_FILTER: microrna_org.filter
}



#
# check provided file is a file, and return its path
#
def is_file(parser, f):
    """
    Checks whether the provided file is a file and return its path.
    """
    if not os.path.isfile(f):
        logger.error("Provided file %s is not a file", f)
        parser.print_help(file=sys.stderr)
        sys.exit(2)

    else:
        return os.path.realpath(f)



#
# check provided arguments satisfy dependencies
#
def operation_provides_required_arguments(operation, cli_args):
    """
    Checks whether the provided operation and CLI arguments are complete.
    """
    required_args = OPTS_DEPENDENCIES[operation]

    provided_args = [
        x for x in required_args if cli_args[x] is not None
    ]

    # check whether the mandatory CLI arguments are provided
    if set(provided_args) != set(required_args):
        logger.error("Missing required command line arguments for operation \"%s\".",
            operation)
        return False

    else:
        return True



#
# run the operation
#
def run(operation, cli_args):
    """
    Runs an operation.
    """

    logger.info("Operation \"%s\" started", operation)
    launch[operation](cache, cli_args)
    logger.info("Operation \"%s\" completed", operation)




#
# main
#
if __name__ == "__main__":

    # parse the command line invocation:
    args, non_args = parser.parse_known_args()

    # no CLI arguments
    # ==> print the help and exit
    if len(sys.argv) == 1:
        parser.print_help(file=sys.stderr)
        sys.exit(0)

    # unrecognised CLI arguments
    # ==> print the help and exit
    if non_args:
        logger.error("Wrong command line invocation. Exiting")
        parser.print_help(file=sys.stderr)
        sys.exit(2)


    # collect CLI arguments
    cli_args = dict(vars(args))

    # operantion's mandatory CLI arguments missing
    # ==> print help and exit
    for op in OPS:

        if (op in cli_args.keys()) and (not operation_provides_required_arguments(op, cli_args)):
            logger.error("Operation \"%s\" is missing mandatory CLI options. Exiting", op)
            parser.print_help(file=sys.stderr)
            sys.exit(2)

    # underlying redis cache not reachable
    # ==> exit
    logger.info("Checking redis cache at %s", cli_args[OPT_DB])
    cache = redis.Redis(
        charset="utf-8", decode_responses=True,
        host=cli_args[OPT_DB].split(SEPARATOR)[0],
        port=cli_args[OPT_DB].split(SEPARATOR)[1],
        db=0)
    try:
        cache.ping()
    except redis.RedisError:
        logger.error("Redis instance not running. Exiting")
        sys.exit(2)


    # launch all operations given on the CLI
    for op in OPS:
        if op in cli_args.keys():
            run(op, cli_args)

